pub mod config;
pub mod error;
pub mod fuzzer;
pub mod rustsdk;
pub mod sampler;
pub mod sway;
pub mod sway_converter;
pub mod ts_converter;
pub mod tssdk;
use config::Config;

use sway::Sway;
use tracing::{error, info};
type Encoding = Vec<u8>;
use clap::Parser;

/// Exercise ABIEncoding
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Path to config file
    #[arg(long)]
    config: Option<String>,

    /// Seed for the random number generator
    #[arg(long)]
    seed: Option<u64>,

    /// Number of fuzzing rounds
    #[arg(long)]
    rounds: Option<u32>,

    /// Number of samples to generate per round
    #[arg(short, long)]
    samples: Option<usize>,

    /// Depth of the generated samples
    #[arg(long)]
    max_depth: Option<usize>,

    /// Build and run the current sway code in forc_project/src/main.sw
    #[arg(long)]
    run_sway: bool,

    /// Output folder used by the fuzzer
    #[arg(long)]
    output_folder: Option<String>,

    /// Minimum length of a generated array
    #[arg(long)]
    array_min_len: Option<usize>,

    /// Maximum length of a generated array
    #[arg(long)]
    array_max_len: Option<usize>,

    /// Minimum length of a generated string
    #[arg(long)]
    string_min_len: Option<usize>,

    /// Maximum length of a generated string
    #[arg(long)]
    string_max_len: Option<usize>,

    /// Minimum number of fields in a generated struct
    #[arg(long)]
    struct_min_fields: Option<usize>,

    /// Maximum number of fields in a generated struct
    #[arg(long)]
    struct_max_fields: Option<usize>,

    /// Minimum number of variants in a generated enum
    #[arg(long)]
    enum_min_variants: Option<usize>,

    /// Maximum number of variants in a generated enum
    #[arg(long)]
    enum_max_variants: Option<usize>,

    /// Minimum length of a generated tuple
    #[arg(long)]
    tuple_min_len: Option<usize>,

    /// Maximum length of a generated tuple
    #[arg(long)]
    tuple_max_len: Option<usize>,

    /// Minimum length of a generated vector
    #[arg(long)]
    vector_min_len: Option<usize>,

    /// Maximum length of a generated vector
    #[arg(long)]
    vector_max_len: Option<usize>,

    /// Minimum length of a generated raw slice
    #[arg(long)]
    slice_min_len: Option<usize>,

    /// Maximum length of a generated raw slice
    #[arg(long)]
    slice_max_len: Option<usize>,

    /// Minimum length of a generated bytes
    #[arg(long)]
    bytes_min_len: Option<usize>,

    /// Maximum length of a generated bytes
    #[arg(long)]
    bytes_max_len: Option<usize>,
}

fn main() {
    let args = Args::parse();

    let mut default_config = Config {
        config: Some("./config.toml".to_string()),
        seed: Some(1),
        rounds: Some(1),
        samples: Some(10),
        max_depth: Some(2),
        output_folder: Some(String::from("./output")),
        string_min_len: Some(1),
        string_max_len: Some(5),
        tuple_min_len: Some(1),
        tuple_max_len: Some(5),
        array_min_len: Some(1),
        array_max_len: Some(5),
        vector_min_len: Some(1),
        vector_max_len: Some(5),
        struct_min_fields: Some(1),
        struct_max_fields: Some(5),
        enum_min_variants: Some(1),
        enum_max_variants: Some(5),
        slice_min_len: Some(1),
        slice_max_len: Some(5),
        bytes_min_len: Some(1),
        bytes_max_len: Some(5),
    };

    let subscriber = tracing_subscriber::FmtSubscriber::new();
    tracing::subscriber::set_global_default(subscriber).unwrap();

    // Modify the config file path
    if let Some(config) = args.config {
        default_config.config = Some(config);
    }

    let mut config_instance = config::load_config(default_config.config.clone().unwrap())
        .unwrap_or_else(|_| {
            error!("Failed to load config.toml, using default values");
            default_config.clone()
        })
        .merge_with_defaults(&default_config);

    if args.run_sway {
        info!("Running sway script only");

        let sway = Sway::new(&config_instance.output_folder.unwrap());
        match sway.build_sway_script() {
            Ok(_) => (),
            Err(e) => {
                error!("Failed to build Sway: {:?}", e);
                return;
            }
        }
        let (encodings, decodings) = sway.run_sway_script();
        info!("Encodings: {:?}", encodings);
        info!("Decodings: {:?}", decodings);
        return;
    }

    if let Some(seed) = args.seed {
        config_instance.seed = Some(seed);
    }
    if let Some(rounds) = args.rounds {
        config_instance.rounds = Some(rounds);
    }
    if let Some(samples) = args.samples {
        config_instance.samples = Some(samples);
    }
    if let Some(max_depth) = args.max_depth {
        config_instance.max_depth = Some(max_depth);
    }
    if let Some(output_folder) = args.output_folder {
        config_instance.output_folder = Some(output_folder);
    }
    if let Some(string_min_len) = args.string_min_len {
        config_instance.string_min_len = Some(string_min_len);
    }
    if let Some(string_max_len) = args.string_max_len {
        config_instance.string_max_len = Some(string_max_len);
    }
    if let Some(tuple_min_len) = args.tuple_min_len {
        config_instance.tuple_min_len = Some(tuple_min_len);
    }
    if let Some(tuple_max_len) = args.tuple_max_len {
        config_instance.tuple_max_len = Some(tuple_max_len);
    }
    if let Some(array_min_len) = args.array_min_len {
        config_instance.array_min_len = Some(array_min_len);
    }
    if let Some(array_max_len) = args.array_max_len {
        config_instance.array_max_len = Some(array_max_len);
    }
    if let Some(vector_min_len) = args.vector_min_len {
        config_instance.vector_min_len = Some(vector_min_len);
    }
    if let Some(vector_max_len) = args.vector_max_len {
        config_instance.vector_max_len = Some(vector_max_len);
    }
    if let Some(struct_min_fields) = args.struct_min_fields {
        config_instance.struct_min_fields = Some(struct_min_fields);
    }
    if let Some(struct_max_fields) = args.struct_max_fields {
        config_instance.struct_max_fields = Some(struct_max_fields);
    }
    if let Some(enum_min_variants) = args.enum_min_variants {
        config_instance.enum_min_variants = Some(enum_min_variants);
    }
    if let Some(enum_max_variants) = args.enum_max_variants {
        config_instance.enum_max_variants = Some(enum_max_variants);
    }
    if let Some(slice_min_len) = args.slice_min_len {
        config_instance.slice_min_len = Some(slice_min_len);
    }
    if let Some(slice_max_len) = args.slice_max_len {
        config_instance.slice_max_len = Some(slice_max_len);
    }
    if let Some(bytes_min_len) = args.bytes_min_len {
        config_instance.bytes_min_len = Some(bytes_min_len);
    }
    if let Some(bytes_max_len) = args.bytes_max_len {
        config_instance.bytes_max_len = Some(bytes_max_len);
    }

    // Create sampler config
    let sampler_config = sampler::SamplerConfig {
        seed: config_instance.seed.unwrap(),
        max_depth: config_instance.max_depth.unwrap(),
        array_max_length: config_instance.array_max_len.unwrap(),
        array_min_length: config_instance.array_min_len.unwrap(),
        string_min_length: config_instance.string_min_len.unwrap(), // Lose due to escape characters added
        string_max_length: config_instance.string_max_len.unwrap(),
        struct_min_fields: config_instance.struct_min_fields.unwrap(),
        struct_max_fields: config_instance.struct_max_fields.unwrap(),
        enum_min_variants: config_instance.enum_min_variants.unwrap(),
        enum_max_variants: config_instance.enum_max_variants.unwrap(),
        tuple_min_length: config_instance.tuple_min_len.unwrap(),
        tuple_max_length: config_instance.tuple_max_len.unwrap(),
        vector_min_length: config_instance.vector_min_len.unwrap(),
        vector_max_length: config_instance.vector_max_len.unwrap(),
        slice_min_length: config_instance.slice_min_len.unwrap(),
        slice_max_length: config_instance.slice_max_len.unwrap(),
        bytes_min_length: config_instance.bytes_min_len.unwrap(),
        bytes_max_length: config_instance.bytes_max_len.unwrap(),
    };

    let sampler = sampler::Sampler::new(sampler_config);

    let mut fuzzer = fuzzer::Fuzzer::new(
        sampler,
        config_instance.rounds.unwrap(),
        config_instance.samples.unwrap(),
        config_instance.output_folder.unwrap().clone(),
    );

    fuzzer.fuzz();

    info!("Fuzzing completed successfully")
}
